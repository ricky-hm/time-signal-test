<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>時報アプリ（Web）</title>
  <style>
    body{font-family:system-ui,-apple-system,Segoe UI,Roboto,"Hiragino Kaku Gothic ProN",Meiryo,Arial;margin:24px;color:#111}
    h1{font-size:1.4rem;margin-bottom:8px}
    .card{border:1px solid #e6e6e6;padding:16px;border-radius:8px;max-width:640px}
    label{display:block;margin:8px 0;font-weight:600}
    input[type=number]{width:80px;padding:6px}
    button{padding:8px 12px;border-radius:6px;border:1px solid #ccc;background:#f7f7f7;cursor:pointer}
    .controls{display:flex;gap:8px;align-items:center;margin-top:12px}
    small{color:#666}
    #clock{font-size:1.2rem;font-weight:bold;margin:12px 0}
  </style>
</head>
<body>
  <div class="card">
    <h1>Web 時報（デスクトップ向け）</h1>
    <p>毎分、指定した秒に電子音を鳴らします（モバイル自動再生非対応）。</p>

    <div id="clock">--:--:--.---</div>

    <label>鳴らす秒（0〜59）
      <input id="secInput" type="number" min="0" max="59" value="0">
    </label>

    <label style="margin-top:6px"><input id="useCountdown" type="checkbox"> カウントダウン音を出す（10秒前＋4秒前から）</label>

    <div class="controls">
      <button id="startBtn">Start</button>
      <button id="stopBtn" disabled>Stop</button>
      <button id="testBtn">Test 音</button>
      <label style="margin-left:auto">音量 <input id="vol" type="range" min="0" max="1" step="0.01" value="0.8"></label>
    </div>

    <p><small>※ブラウザのオートプレイ制限のため、Startは必ずクリックしてください。高精度は AudioContext のスケジューリングで確保しています。</small></p>
    <div id="log" style="margin-top:12px;color:#333;background:#fafafa;padding:8px;border-radius:6px;max-height:160px;overflow:auto;font-size:0.9rem"></div>
  </div>

  <script>
    const secInput = document.getElementById('secInput');
    const startBtn = document.getElementById('startBtn');
    const stopBtn = document.getElementById('stopBtn');
    const testBtn = document.getElementById('testBtn');
    const volRange = document.getElementById('vol');
    const useCountdown = document.getElementById('useCountdown');
    const logEl = document.getElementById('log');
    const clockEl = document.getElementById('clock');

    let audioCtx = null;
    let masterGain = null;
    let running = false;
    let schedulerInterval = null;
    const scheduledTimes = new Set();
    let serverTimeOffset = 0;

    function log(s){
      const t = getAccurateTime().toLocaleTimeString('ja-JP', {hour12:false}) + '.' + String(getAccurateTime().getMilliseconds()).padStart(3,'0');
      logEl.innerHTML = `<div>[${t}] ${s}</div>` + logEl.innerHTML;
    }

    async function syncTime(){
      try {
        const res = await fetch('https://worldtimeapi.org/api/timezone/Asia/Tokyo');
        const data = await res.json();
        const serverMillis = new Date(data.datetime).getTime();
        serverTimeOffset = serverMillis - Date.now();
        log('NTP相当の時間同期完了（日本標準時）');
      } catch(e) {
        log('時間同期に失敗しました');
        serverTimeOffset = 0;
      }
    }

    function getAccurateTime(){
      return new Date(Date.now() + serverTimeOffset);
    }

    function updateClock(){
      const now = getAccurateTime();
      const formatted = `${String(now.getHours()).padStart(2,'0')}:${String(now.getMinutes()).padStart(2,'0')}:${String(now.getSeconds()).padStart(2,'0')}.${String(now.getMilliseconds()).padStart(3,'0')}`;
      clockEl.textContent = formatted;
    }
    setInterval(updateClock, 30);
    updateClock();

    function ensureAudioContext(){
      if (!audioCtx){
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        masterGain = audioCtx.createGain();
        masterGain.gain.value = parseFloat(volRange.value);
        masterGain.connect(audioCtx.destination);
      }
    }

    function createBeep(delay, duration = 0.6, freq = 880){
      const osc = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      osc.type = 'sine';
      osc.frequency.value = freq;
      g.gain.setValueAtTime(0.0001, audioCtx.currentTime + delay);
      g.gain.linearRampToValueAtTime(1.0, audioCtx.currentTime + delay + 0.01);
      g.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + delay + duration);
      osc.connect(g);
      g.connect(masterGain);
      osc.start(audioCtx.currentTime + delay);
      osc.stop(audioCtx.currentTime + delay + duration + 0.05);
    }

    function beepAtTimestampMs(targetMs, opts = {}){
      if (!audioCtx) return;
      const nowMs = Date.now() + serverTimeOffset;
      const delta = (targetMs - nowMs)/1000;
      if (delta < -0.1) return;
      const d = Math.max(0.0, delta);
      createBeep(d, opts.duration || 0.6, opts.freq || 880);
      log(`スケジュール: ${getAccurateTime().toLocaleTimeString('ja-JP', {hour12:false})}`);
    }

    function computeNextTargetMs(sec){
      const now = getAccurateTime();
      const target = new Date(now.getFullYear(), now.getMonth(), now.getDate(), now.getHours(), now.getMinutes(), sec, 0);
      if (target.getTime() <= Date.now() + serverTimeOffset) target.setMinutes(target.getMinutes() + 1);
      return target.getTime();
    }

    function scheduleIfNeeded(){
      if (!running) return;
      const sec = parseInt(secInput.value, 10) || 0;
      const nextMs = computeNextTargetMs(sec);
      const delta = nextMs - (Date.now() + serverTimeOffset);
      if (delta <= 11000 && !scheduledTimes.has(nextMs)){
        if (useCountdown.checked){
          const t10 = nextMs - 10000;
          if (t10 > Date.now() + serverTimeOffset && !scheduledTimes.has(t10)){
            beepAtTimestampMs(t10, {duration:1.2, freq:660});
            scheduledTimes.add(t10);
          }
          for (let i=4;i>=1;i--){
            const t = nextMs - i*1000;
            if (!scheduledTimes.has(t) && t > Date.now() + serverTimeOffset){
              beepAtTimestampMs(t, {duration:0.12, freq:1400});
              scheduledTimes.add(t);
            }
          }
        }
        beepAtTimestampMs(nextMs, {duration:0.9, freq:520});
        scheduledTimes.add(nextMs);
      }
      const cutoff = Date.now() + serverTimeOffset - 60000;
      for (const t of Array.from(scheduledTimes)){
        if (t < cutoff) scheduledTimes.delete(t);
      }
    }

    async function start(){
      ensureAudioContext();
      await syncTime();
      audioCtx.resume().then(()=>{
        running = true;
        scheduledTimes.clear();
        if (schedulerInterval) clearInterval(schedulerInterval);
        schedulerInterval = setInterval(scheduleIfNeeded, 50);
        startBtn.disabled = true;
        stopBtn.disabled = false;
        log('時報を開始しました');
      });
    }

    function stop(){
      running = false;
      if (schedulerInterval) clearInterval(schedulerInterval);
      scheduledTimes.clear();
      startBtn.disabled = false;
      stopBtn.disabled = true;
      log('時報を停止しました');
    }

    startBtn.addEventListener('click', start);
    stopBtn.addEventListener('click', stop);

    testBtn.addEventListener('click', async ()=>{
      ensureAudioContext();
      await audioCtx.resume();
      createBeep(0.02, 0.9, 520);
      log('テスト音を鳴らしました');
    });

    volRange.addEventListener('input', ()=>{
      if (masterGain) masterGain.gain.value = parseFloat(volRange.value);
    });

    secInput.addEventListener('change', ()=>{
      scheduledTimes.clear();
      log(`鳴らす秒を ${secInput.value} に変更しました`);
    });

    useCountdown.addEventListener('change', ()=>{
      scheduledTimes.clear();
    });

    try{
      const saved = localStorage